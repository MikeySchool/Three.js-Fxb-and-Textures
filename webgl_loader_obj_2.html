<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - loaders - OBJ loader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #000;
            color: #fff;
            margin: 0px;
            overflow: hidden;
        }

        .btn-explode {
            position: absolute;
            bottom: 20px;
            left: 45%;
        }

    </style>
</head>

<body>
    <script src="js/threejs/three.min.js"></script>
    <script src="js/libs/stats.min.js"></script>
    <script src="js/loaders/OBJLoader.js"></script>
    <script src="js/controls/OrbitControls.js"></script>

    <div class="btn-explode">
        <button onclick="ExplodeProduct()">Explode</button>
        <button onclick="ImplodeProduct()">Implode</button>
    </div>


    <script>
        var container, camera, scene, renderer, controls, raycaster, parts,
            mouse = new THREE.Vector2(),
            INTERSECTED;

        init();
        animate();

        function init() {

            container = document.createElement('div');
            document.body.appendChild(container);

            // Camera
            camera = new THREE.PerspectiveCamera(10, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.set(100, 10, 300);

            controls = new THREE.OrbitControls(camera);
            controls.target.set(0, 0, 0);
            controls.update();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            //            scene.fog = new THREE.Fog(0xa0a0a0, 200, 1000);

            //            light = new THREE.HemisphereLight(0xffffff, 0x444444);
            //            light.position.set(0, 100, 0);
            //            scene.add(light);
            //
            //            light = new THREE.DirectionalLight(0xbfbfbf);
            //            light.position.set(0, 50, 0);
            //            light.castShadow = true;
            //            light.shadow.camera.top = 180;
            //            light.shadow.camera.bottom = -100;
            //            light.shadow.camera.left = -120;
            //            light.shadow.camera.right = 120;
            //            scene.add(light);

            var ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            var pointLight = new THREE.PointLight(0xffffff, 0.3);
            camera.add(pointLight);
            scene.add(camera);

            // ground
            var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2000, 2000), new THREE.MeshPhongMaterial({
                color: 0xffffff,
                depthWrite: false
            }));
            mesh.rotation.x = -Math.PI / 2;
            mesh.receiveShadow = true;
            scene.add(mesh);

            //            var grid = new THREE.GridHelper(2000, 20, 0x000000, 0x000000);
            //            grid.material.opacity = 0.2;
            //            grid.material.transparent = true;
            //            scene.add(grid);

            // Model
            var onProgress = function(xhr) {
                if (xhr.lengthComputable) {
                    var percentComplete = xhr.loaded / xhr.total * 100;
                    console.log(Math.round(percentComplete, 2) + '% downloaded');
                }
            };

            var onError = function(xhr) {};

            var loader = new THREE.OBJLoader();
            loader.load('models/obj/S19AOBA241.obj', function(object) {
                object.traverse(function(child) {
                    if (child instanceof THREE.Mesh) {
                        child.material = new THREE.MeshPhongMaterial({
                            color: 0xFFFFFF
                        });;
                    }
                });
                scene.add(object);

                parts = object.children;
            }, onProgress, onError);

            raycaster = new THREE.Raycaster();

            // Renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setClearColor(0xf0f0f0);

            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.sortObjects = false;
            container.appendChild(renderer.domElement);

            document.addEventListener('mousemove', onDocumentMouseMove, false);
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        // Animation
        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {

            //            theta += 0.1;
            //
            //            camera.position.x = radius * Math.sin(THREE.Math.degToRad(theta));
            //            camera.position.y = radius * Math.sin(THREE.Math.degToRad(theta));
            //            camera.position.z = radius * Math.cos(THREE.Math.degToRad(theta));
            //            camera.lookAt(scene.position);
            //
            //            camera.updateMatrixWorld();

            // find intersections
            //if (skull){
            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {

                if (INTERSECTED != intersects[0].object) {

                    if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);

                    INTERSECTED = intersects[0].object;

                    if (INTERSECTED.name !== "") {
                        INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                        INTERSECTED.material.emissive.setHex(0xff0000);
                    }
                }

            } else {
                if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);

                INTERSECTED = null;
            }
            //}
            renderer.render(scene, camera);
        }

        function CalculateCenter() {
            // Calculate center of each part
            var centers = [];
            parts.forEach(function(i, v) {
                i.geometry.computeBoundingSphere();
                centers.push(i.geometry.boundingSphere.center);
            });

            // Average the centers of the various parts to find the center of them all together
            var center = new THREE.Vector3();
            centers.forEach(function(vec) {
                center = center.add(vec);
            });
            center.x /= centers.length;
            center.y /= centers.length;
            center.z /= centers.length;

            return center;
        }

        function ExplodeProduct() {
            const center = CalculateCenter();

            // Go through each part and move them away from the center
            parts.forEach(function(i, v) {
                // Finding the vector between the center and the part and normalising it
                var childCenter = i.geometry.boundingSphere.center;
                var direction = childCenter.sub(center);
                direction = direction.normalize();

                // Moving the part in the direction
                i.position.x += direction.x;
                i.position.y += direction.y;
                i.position.z += direction.z;
            });
        }

        function ImplodeProduct() {
            const center = CalculateCenter();

            // Go through each part and move them away from the center
            parts.forEach(function(i, v) {
                // Finding the vector between the center and the part and normalising it
                var childCenter = i.geometry.boundingSphere.center;
                var direction = childCenter.sub(center);
                direction = direction.normalize();

                // Moving the part in the direction
                i.position.x -= direction.x;
                i.position.y -= direction.y;
                i.position.z -= direction.z;
            });
        }

    </script>

</body>

</html>
